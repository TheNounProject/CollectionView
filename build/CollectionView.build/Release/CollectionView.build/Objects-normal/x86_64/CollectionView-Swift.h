// Generated by Apple Swift version 4.0.3 (swiftlang-900.0.74.1 clang-900.0.39.2)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_attribute(external_source_symbol)
# define SWIFT_STRINGIFY(str) #str
# define SWIFT_MODULE_NAMESPACE_PUSH(module_name) _Pragma(SWIFT_STRINGIFY(clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in=module_name, generated_declaration))), apply_to=any(function, enum, objc_interface, objc_category, objc_protocol))))
# define SWIFT_MODULE_NAMESPACE_POP _Pragma("clang attribute pop")
#else
# define SWIFT_MODULE_NAMESPACE_PUSH(module_name)
# define SWIFT_MODULE_NAMESPACE_POP
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR __attribute__((enum_extensibility(open)))
# else
#  define SWIFT_ENUM_ATTR
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import AppKit;
@import Foundation;
@import CoreGraphics;
@import ObjectiveC;
@import CoreData;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

SWIFT_MODULE_NAMESPACE_PUSH("CollectionView")
@class NSCoder;
@class NSWindow;
@class NSEvent;

SWIFT_CLASS("_TtC14CollectionView8ClipView")
@interface ClipView : NSClipView
- (nonnull instancetype)initWithFrame:(NSRect)frameRect SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)viewWillMoveToWindow:(NSWindow * _Nullable)newWindow;
- (void)mouseDown:(NSEvent * _Nonnull)event;
- (void)scrollToPoint:(NSPoint)newOrigin;
@end


/// The CollectionReusableView class defines the behavior for all cells and supplementary views presented by a collection view. Reusable views are so named because the collection view places them on a reuse queue rather than deleting them when they are scrolled out of the visible bounds. Such a view can then be retrieved and repurposed for a different set of content.
SWIFT_CLASS("_TtC14CollectionView22CollectionReusableView")
@interface CollectionReusableView : NSView
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
/// Performs any clean up necessary to prepare the view for use again.
- (void)prepareForReuse;
- (void)updateLayer;
- (void)drawRect:(NSRect)dirtyRect;
- (void)updateTrackingAreas;
@end


SWIFT_CLASS("_TtC14CollectionView10ScrollView")
@interface ScrollView : NSScrollView
- (nonnull instancetype)initWithFrame:(NSRect)frameRect SWIFT_UNAVAILABLE;
@property (nonatomic, readonly, getter=isFlipped) BOOL flipped;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end

@protocol CollectionViewDelegate;
@class NSDraggingSession;
@protocol NSDraggingInfo;

/// A Collection View manages the presentation of items, your app’s main job is to provide the data that those items are to represent.
/// A collection view gets its data from the data source, which is an object that conforms to the CollectionViewDataSource protocol. Data provided by the data source is represented items, which can also be organized into sections, and ultimately displayed as cells.
/// <h3>Gathings Data</h3>
/// The data source only has 3 requirements, provide the number of sections, the number of items, and a cell for each item. For performance, cells in a collection view are reusable since only a subset of all the items will often be visbile.
/// Before you can load a cell, you need to register the cells you will need to represet your data. Cells can be registered from a nib or from a class using <code>register(class:forCellWithReuseIdentifier:)</code> or <code>register(nib:forCellWithReuseIdentifier:)</code>. The reuse identifier will later be use to get instances of the cell.
/// To create the cells for each item in your data, implement the data source method <code>func collectionView(_:cellForItemAt:) -> CollectionViewCell</code>. In here you will call <code>dequeueReusableCell(withReuseIdentifier:for:)</code> which will load an instance of the cell your previously registered for that resuse identifier. After you have dequeued the cell, update it as needed to properly represent the object at the given index path in your data, then return it.
/// <h3>Laying Out Items</h3>
/// After the data source has provided all the cells to be displayed, the collection view looks to its CollectionViewLayout to determine where to place each one. The base layout object is designed to be subclassed to generate layout information for different use cases. The goal of a layout is to be able to provide information about the layout to the collection view quickly, this inlcudes the location of each cell, the overall size of all the items, etc.
/// The following layouts are provided for common uses, for more custom layouts, create a custom CollectionViewLayout subclass.
/// <ul>
///   <li>
///     CollectionViewColumnLayout
///   </li>
///   <li>
///     CollectionViewListLayout
///   </li>
///   <li>
///     CollectionViewFlowLayout
///   </li>
///   <li>
///     CollectionViewHorizontalLayout
///   </li>
/// </ul>
SWIFT_CLASS("_TtC14CollectionView14CollectionView")
@interface CollectionView : ScrollView <NSDraggingSource>
@property (nonatomic, readonly) BOOL mouseDownCanMoveWindow;
/// The object that acts as the delegate to the collection view
@property (nonatomic, weak) id <CollectionViewDelegate> _Nullable delegate;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSScrollerStyle scrollerStyle;
@property (nonatomic, readonly) BOOL wantsUpdateLayer;
- (void)updateLayer;
/// The total size of all items/views
@property (nonatomic, readonly) NSSize contentSize;
- (void)layout;
- (void)viewWillStartLiveResize;
- (void)viewDidEndLiveResize;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, getter=isCompatibleWithResponsiveScrolling) BOOL compatibleWithResponsiveScrolling;)
+ (BOOL)isCompatibleWithResponsiveScrolling SWIFT_WARN_UNUSED_RESULT;
- (void)updateTrackingAreas;
- (void)mouseExited:(NSEvent * _Nonnull)theEvent;
- (void)mouseMoved:(NSEvent * _Nonnull)theEvent;
@property (nonatomic, readonly) BOOL acceptsFirstResponder;
- (BOOL)acceptsFirstMouse:(NSEvent * _Nullable)theEvent SWIFT_WARN_UNUSED_RESULT;
- (BOOL)becomeFirstResponder SWIFT_WARN_UNUSED_RESULT;
- (BOOL)resignFirstResponder SWIFT_WARN_UNUSED_RESULT;
- (void)mouseDown:(NSEvent * _Nonnull)theEvent;
- (void)mouseUp:(NSEvent * _Nonnull)theEvent;
- (void)rightMouseDown:(NSEvent * _Nonnull)theEvent;
- (void)keyDown:(NSEvent * _Nonnull)theEvent;
- (void)keyUp:(NSEvent * _Nonnull)theEvent;
- (void)mouseDragged:(NSEvent * _Nonnull)theEvent;
- (NSDragOperation)draggingSession:(NSDraggingSession * _Nonnull)session sourceOperationMaskForDraggingContext:(NSDraggingContext)context SWIFT_WARN_UNUSED_RESULT;
- (void)draggingSession:(NSDraggingSession * _Nonnull)session willBeginAtPoint:(NSPoint)screenPoint;
- (void)draggingSession:(NSDraggingSession * _Nonnull)session movedToPoint:(NSPoint)screenPoint;
- (void)draggingSession:(NSDraggingSession * _Nonnull)session endedAtPoint:(NSPoint)screenPoint operation:(NSDragOperation)operation;
- (NSDragOperation)draggingEntered:(id <NSDraggingInfo> _Nonnull)sender SWIFT_WARN_UNUSED_RESULT;
- (void)draggingExited:(id <NSDraggingInfo> _Nullable)sender;
- (void)draggingEnded:(id <NSDraggingInfo> _Nonnull)sender;
- (NSDragOperation)draggingUpdated:(id <NSDraggingInfo> _Nonnull)sender SWIFT_WARN_UNUSED_RESULT;
- (BOOL)performDragOperation:(id <NSDraggingInfo> _Nonnull)sender SWIFT_WARN_UNUSED_RESULT;
@end






/// A CollectionViewCell object presents the content for a single data item when that item is within the collection view’s visible bounds. You can use this class as-is or subclass it to add additional properties and methods. The layout and presentation of cells is managed by the collection view and its corresponding layout object.
SWIFT_CLASS("_TtC14CollectionView18CollectionViewCell")
@interface CollectionViewCell : CollectionReusableView
- (BOOL)acceptsFirstMouse:(NSEvent * _Nullable)theEvent SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)prepareForReuse;
- (void)mouseEntered:(NSEvent * _Nonnull)theEvent;
- (void)mouseExited:(NSEvent * _Nonnull)theEvent;
@end


/// The CollectionViewLayout class is an abstract base class that you subclass and use to generate layout information for a collection view. The job of a layout object is to determine the placement of cells, supplementary views inside the collection view’s bounds and to report that information to the collection view when asked. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.
SWIFT_CLASS("_TtC14CollectionView20CollectionViewLayout")
@interface CollectionViewLayout : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// This layout is column based which means you provide the number of columns and cells are placed in the appropriate one. It can be display items all the same size or as a “Pinterest” style layout.
/// The number of columns can be set dynamically by the delegate or you can provide a default value using <code>layout.columnCount</code>.
/// You can also set the <code>sectionInsets</code> and <code>minimumColumnSpacing</code> which will affect the width of each column.
/// With the itemWidth set by the column, you have 3 options to set the height of each item. They are used in the order here. So if aspectRatioForItemAtIndexPath is implemented it is used, otherwise, it checks the next one.
/// <ol>
///   <li>
///     aspectRatioForItemAtIndexPath (delegate)
///   </li>
///   <li>
///     heightForItemAtIndexPath (delegate)
///   </li>
///   <li>
///     layout.defaultItemHeight
///   </li>
/// </ol>
/// The delegate method aspectRatioForItemAtIndexPath scales the size of the cell to maintain that ratio while fitting within the caclulated column width.
/// Mixed use of ratios and heights is also supported. Returning CGSize.zero for a ratio will fall back to the hight. If a valid ratio and height are provided, the height will be appended to the height to respect the ratio. For example, if the column width comes out to 100, a ratio of 1:2 will determine a height of 200. If a height is also provided by the delegate for the same item, say 20 it will be added, totalling 220.
SWIFT_CLASS("_TtC14CollectionView26CollectionViewColumnLayout")
@interface CollectionViewColumnLayout : CollectionViewLayout
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The CollectionViewDelegate protocol defines methods that allow you to manage the status, selection, highlighting, and scrolling of items in a collection view and to perform actions on those items. The methods of this protocol are all optional.
SWIFT_PROTOCOL("_TtP14CollectionView22CollectionViewDelegate_")
@protocol CollectionViewDelegate
@optional
/// Notifies the delegate that the collection view will reload it’s layout
/// It can be assumed that the data has been reloaded
/// note:
/// Calculating layout properties that can be cached can be done here and later returned in associated the layout delegate methods.
/// \param collectionView The collection view is reloading it’s layout
///
- (void)collectionViewWillReloadLayout:(CollectionView * _Nonnull)collectionView;
/// Notifies the delegate that the collection view finished reloading it’s layout
/// \code
/// It can be assumed that the data has been reloaded and  is up to date
///
/// \endcode\param collectionView The collection view
///
- (void)collectionViewDidReloadLayout:(CollectionView * _Nonnull)collectionView;
/// Notifies the delegate that the collection view has changed status as first responder
/// \param collectionView The collection view changing status
///
/// \param firstResponder True if the collection view is first responder
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didChangeFirstResponderStatus:(BOOL)firstResponder;
/// Notifies the delegate that the mouse has moved into the frame of a section.
/// note:
/// trackSectionHover must be set to true on the collection view
/// \param collectionView The collection view notifying you of the event
///
/// \param indexPath the index path of the section
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView mouseMovedToSection:(NSIndexPath * _Nullable)indexPath;
/// Notifies the delegate that the mouse was clicked down in the specified index path
/// \param collectionView The collection view recieving the click
///
/// \param indexPath The index path of the item at the click location, or nil
///
/// \param event The click event
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView mouseDownInItemAt:(NSIndexPath * _Nullable)indexPath with:(NSEvent * _Nonnull)event;
/// Notifies the delegate that the mouse was released in the specified index path
/// \param collectionView The collection view receiving the click
///
/// \param indexPath The index path of the item at the click location, or nil
///
/// \param event The click even
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView mouseUpInItemAt:(NSIndexPath * _Nullable)indexPath with:(NSEvent * _Nonnull)event;
/// Asks the delegate if the item at the specified index path should highlight
/// \param collectionView The asking collection view
///
/// \param indexPath The index path of the item to highlight
///
///
/// returns:
/// True if the item should highlight
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldHighlightItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldDeselectItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Please use collectionView(_:, shouldDeselectItemsAt:)");
- (void)collectionView:(CollectionView * _Nonnull)collectionView didDeselectItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_MSG("Please use collectionView(_:, didDeselectItemsAt:)");
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldSelectItemAt:(NSIndexPath * _Nonnull)indexPath with:(NSEvent * _Nullable)event SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Please use collectionView(_:, shouldSelectItemsAt:)");
- (void)collectionView:(CollectionView * _Nonnull)collectionView didSelectItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_MSG("Please use collectionView(_:, didSelectItemsAt:)");
/// Asks the delegate to approve the pending selection of items.
/// Use this method to approve or modify the items that the user tries to select. During interactive selection, the collection view calls this method whenever the user selects new items. Your implementation of the method can return the proposed set of index paths as-is or modify the set before returning it. You might modify the set to disallow the selection of specific items or specific combinations of items.
/// If you do not implement this method, the collection view selects the items specified by the indexPaths parameter.
/// \param collectionView The collection view making the request.
///
/// \param indexPath The set of NSIndexPath objects corresponding to the items selected by the user.
///
/// \param event The event that cause the selection
///
///
/// returns:
/// The set of NSIndexPath objects corresponding to the items that you want to be selected. If you do not want any items selected, return an empty set.
- (NSSet<NSIndexPath *> * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView shouldSelectItemsAt:(NSSet<NSIndexPath *> * _Nonnull)indexPaths SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate object that one or more items were selected.
/// After the user successfully selects one or more items, the collection view calls this method to let you know that the selection has been made. Use this method to respond to the selection change and to make any necessary adjustments to your content or the collection view.
/// note:
/// The provided index paths do not inlcude index paths selected prior to this event.
/// \param collectionView The collection view notifying you of the selection change.
///
/// \param indexPath The set of NSIndexPath objects corresponding to the items that are now selected.
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didSelectItemsAt:(NSSet<NSIndexPath *> * _Nonnull)indexPaths;
/// Asks the delegate object to approve the pending deselection of items.
/// Use this method to approve or modify the items that the user tries to deselect. During interactive selection, the collection view calls this method whenever the user deselects items. Your implementation of the method can return the proposed set of index paths as-is or modify the set before returning it. You might modify the set to disallow the deselection of specific items.
/// \param collectionView The collection view making the request.
///
/// \param indexPath The set of NSIndexPath objects corresponding to the items deselected by the user.
///
///
/// returns:
/// The set of NSIndexPath objects corresponding to the items that you want to be selected. If you do not want any items selected return an empty set.
- (NSSet<NSIndexPath *> * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView shouldDeselectItemsAt:(NSSet<NSIndexPath *> * _Nonnull)indexPaths SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate object that one or more items were deselected.
/// After the user successfully deselects one or more items, the collection view calls this method to let you know that the items are no longer selected. Use this method to respond to the selection change and to make any necessary adjustments to your content or the collection view.
/// \param collectionView The collection view notifying you of the selection change.
///
/// \param indexPath The set of NSIndexPath objects corresponding to the items that were deselected.
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didDeselectItemsAt:(NSSet<NSIndexPath *> * _Nonnull)indexPaths;
/// Not implemented
/// \param collectionView <#collectionView description#>
///
/// \param pressure <#pressure description#>
///
/// \param indexPath <#indexPath description#>
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didChangePressure:(CGFloat)pressure forItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_UNAVAILABLE_MSG("Trackpad pressure is not yet implemented");
/// Notifies the delegate that an item was double clicked
/// \param collectionView The collection view containing the clicked item
///
/// \param indexPath The index path of the clicked item
///
/// \param event The click event that double clicked the item
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didDoubleClickItemAt:(NSIndexPath * _Nullable)indexPath with:(NSEvent * _Nonnull)event;
/// Notifies the delegate that an item was right clicked
/// \param collectionView The collection view containing the clicked item
///
/// \param indexPath The index path of the clicked item
///
/// \param event The click event
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didRightClickItemAt:(NSIndexPath * _Nullable)indexPath with:(NSEvent * _Nonnull)event;
- (void)collectionView:(CollectionView * _Nonnull)collectionView willDisplayCell:(CollectionViewCell * _Nonnull)cell forItemAt:(NSIndexPath * _Nonnull)indexPath;
/// Notifies the delegate that a supplementary view will bw displayed
/// \param collectionView The collection view containing the supplementary view
///
/// \param elementKind The element kind of the view
///
/// \param indexPath The index path of the view
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView willDisplaySupplementaryView:(CollectionReusableView * _Nonnull)view ofElementKind:(NSString * _Nonnull)elementKind at:(NSIndexPath * _Nonnull)indexPath;
/// Notifies the delegate that a cell was removed from view
/// \param collectionView The collection view containing the cell
///
/// \param cell The cell that was removed
///
/// \param indexPath The index path of the removed cell
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didEndDisplayingCell:(CollectionViewCell * _Nonnull)cell forItemAt:(NSIndexPath * _Nonnull)indexPath;
/// Notifies the delegate that a supplementary view was removed from view
/// \param collectionView The collection view containing the supplementary view
///
/// \param view The view that was removed
///
/// \param elementKind The kind of the removed element
///
/// \param indexPath The index path of the removed view
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didEndDisplayingSupplementaryView:(CollectionReusableView * _Nonnull)view ofElementKind:(NSString * _Nonnull)elementKind at:(NSIndexPath * _Nonnull)indexPath;
/// Asks the delegate for an index path to anchor when resizing
/// Defaults to an index path for one of the first visible items
/// \param collectionView The collection view
///
///
/// returns:
/// The index path to anchor to when resizing
- (NSIndexPath * _Nullable)collectionViewLayoutAnchor:(CollectionView * _Nonnull)collectionView SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate that the collection view did begin resizing
/// \param collectionView The collection view
///
- (void)collectionViewDidEndLiveResize:(CollectionView * _Nonnull)collectionView;
/// Asks the delegate if the collection view should scroll to an item
/// \param collectionView The collection view
///
/// \param indexPath The index path that may be scrolled to
///
///
/// returns:
/// True if the collection view should perform the scroll
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldScrollToItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate that the collection view did complete a scrolling action
/// \param collectionView The collection view that performed a scrolling animation
///
/// \param indexPath The index path that was scrolled to
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView didScrollToItemAt:(NSIndexPath * _Nonnull)indexPath;
/// Notifies the delegate that the collection view was scrolled
/// Because this is called continuously as the scroll position is changed, beware of performance.
/// \param collectionView The collection view that was scrolled
///
- (void)collectionViewDidScroll:(CollectionView * _Nonnull)collectionView;
/// Notifies the delegate that the collection view will begin scrolling
/// \param collectionView The collection view that will begin scrolling
///
/// \param aniated If the scroll is triggered by user input, this will be false
///
- (void)collectionViewWillBeginScrolling:(CollectionView * _Nonnull)collectionView animated:(BOOL)animated;
/// Notifies the delegate that the collection view did end scrolling
/// \param collectionView The collection view that was scrolled
///
/// \param animated True if the scroll was animated (false for user driven scrolling)
///
- (void)collectionViewDidEndScrolling:(CollectionView * _Nonnull)collectionView animated:(BOOL)animated;
@end

@protocol NSPasteboardWriting;
@class NSImage;

/// The CollectionViewDataSource is responsible for providing the data and views required by a collection view
/// <h1>Overview</h1>
/// At a minimum, all data source objects must implement the numberOfSections(in:), collectionView(<em>:numberOfItemsInSection:) and collectionView(</em>:cellForItemAt:) methods. These methods are responsible for returning the number of items in the collection view along with the items themselves.
SWIFT_PROTOCOL("_TtP14CollectionView24CollectionViewDataSource_")
@protocol CollectionViewDataSource
/// Asks your data source for the number of sections in the collectin view
/// \param collectionView The collection view requesting this information.
///
///
/// returns:
/// The number of sections in collectionView.
- (NSInteger)numberOfSectionsIn:(CollectionView * _Nonnull)collectionView SWIFT_WARN_UNUSED_RESULT;
/// Asks your data source object for the number of items in the specified section.
/// \param collectionView The collection view requesting this information.
///
/// \param section An index number identifying a section in collectionView. This index value is 0-based.
///
///
/// returns:
/// The number of items in the specified section
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks your data source object for the cell that corresponds to the specified item in the collection view.
/// <h1>Discussion</h1>
/// Your implementation of this method is responsible for creating, configuring, and returning the appropriate cell for the given item. You do this by calling the dequeueReusableCell(withReuseIdentifier:for:) method of the collection view and passing the reuse identifier that corresponds to the cell type you want. That method always returns a valid cell object. Upon receiving the cell, you should set any properties that correspond to the data of the corresponding item, perform any additional needed configuration, and return the cell.
/// You do not need to set the location of the cell inside the collection view’s bounds. The collection view sets the location of each cell automatically using the layout attributes provided by its layout object.
/// \param collectionView The collection view requesting this information.
///
/// \param indexPath The index path that specifies the location of the item.
///
///
/// returns:
/// A configured cell object. You must not return nil from this method.
- (CollectionViewCell * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView cellForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
@optional
/// Asks your data source object to provide a supplementary view to display in the collection view.
/// <h1>Discussion</h1>
/// Your implementation of this method is responsible for creating, configuring, and returning the appropriate supplementary view that is being requested. You do this by calling the dequeueReusableSupplementaryView(ofKind:withReuseIdentifier:for:) method of the collection view and passing the information that corresponds to the view you want. That method always returns a valid view object. Upon receiving the view, you should set any properties that correspond to the data you want to display, perform any additional needed configuration, and return the view.
/// You do not need to set the location of the supplementary view inside the collection view’s bounds. The collection view sets the location of each view using the layout attributes provided by its layout object.
/// \param collectionView The collection view requesting this information.
///
/// \param kind The kind of supplementary view to provide. The value of this string is defined by the layout object that supports the supplementary view.
///
/// \param indexPath The index path that specifies the location of the new supplementary view.
///
///
/// returns:
/// A configured supplementary view object. You must not return nil from this method.
- (CollectionReusableView * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView viewForSupplementaryElementOfKind:(NSString * _Nonnull)kind at:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Asks your data source for a pasteboard writing for the item at the specified index path
/// \param collectionView The collection view requesting this information.
///
/// \param indexPath The index path of the item to represent with the pasteboard writer
///
///
/// returns:
/// The pasteboard writer object to use for managing the item data. Return nil to prevent the collection view from dragging the item.
- (id <NSPasteboardWriting> _Nullable)collectionView:(CollectionView * _Nonnull)collectionView pasteboardWriterForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Asks the data source for the drag contents for the item at the specified index path
/// note:
/// If nil is returned, a snapshot of the cell will be used. To disable dragging for an item return false for shouldStartDragging or remove the index path during validation
/// \param collectionView The collection view requesting this information.
///
/// \param indexPath The index path of the item to represent
///
///
/// returns:
/// An NSImage to display when dragging the item
- (NSImage * _Nullable)collectionView:(CollectionView * _Nonnull)collectionView dragContentsForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Asks the data source to validate the drag rect for an item to be dragged, allowing for adjustment.
/// \param collectionView The collection view requesting this information.
///
/// \param indexPath The index path of the item being dragged
///
/// \param rect The current rect of the item
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView dragRectForItemAt:(NSIndexPath * _Nonnull)indexPath withStartingRect:(CGRect * _Nonnull)rect;
@end

@class NSBundle;

/// The UICollectionViewController class represents a view controller whose content consists of a collection view.
SWIFT_CLASS("_TtC14CollectionView24CollectionViewController")
@interface CollectionViewController : NSViewController <CollectionViewDataSource, CollectionViewDelegate>
- (void)loadView;
- (void)viewDidLoad;
- (NSInteger)numberOfSectionsIn:(CollectionView * _Nonnull)collectionView SWIFT_WARN_UNUSED_RESULT;
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
- (CollectionViewCell * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView cellForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithNibName:(NSNibName _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// The delegate for CollectionViewColumnLayout to dynamically customize the layout
SWIFT_PROTOCOL("_TtP14CollectionView34CollectionViewDelegateColumnLayout_")
@protocol CollectionViewDelegateColumnLayout <CollectionViewDelegate>
@optional
/// Asks the delegate for the number fo columns in a section
/// \param collectionView The collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// The desired number of columns in the section
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout numberOfColumnsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for insets to be applied to content of a given section
/// \param collectionView The collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// <#EdgeInsets return description#>
- (NSEdgeInsets)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout insetForSectionAt:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the item spacing to be applied to items of the same column of a section
/// \param collectionView The collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// <#CGFloat return description#>
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout interitemSpacingForSectionAt:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the column spacing to applied to items in a given section
/// \param collectionView The collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// <#CGFloat return description#>
- (CGFloat)collectionview:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout columnSpacingForSectionAt:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// The height for the item at the given indexPath (Priority 2)
/// \param collectionView The collection view the item is in
///
/// \param collectionViewLayout The CollectionViewLayout
///
/// \param indexPath The indexPath for the item
///
///
/// returns:
/// The height for the item
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// The aspect ration for the item at the given indexPath (Priority 1). Width and height must be greater than 0.
/// \param collectionView The collection view the item is in
///
/// \param collectionViewLayout The CollectionViewLayout
///
/// \param indexPath The indexPath for the item
///
///
/// returns:
/// The aspect ration for the item
- (CGSize)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout aspectRatioForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the height of the header in the given section
/// \param collectionView The collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// The desired header height or 0 for no header
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the height of the footer in the given section
/// \param collectionView The collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// The desired footer height or 0 for no footer
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
@end


/// The delegate for CollectionViewHorizontalListLayout
SWIFT_PROTOCOL("_TtP14CollectionView42CollectionViewDelegateHorizontalListLayout_")
@protocol CollectionViewDelegateHorizontalListLayout <CollectionViewDelegate>
@optional
/// Asks the delegate for the width of the item at a given index path
/// \param collectionView The collection view containing the item
///
/// \param collectionViewLayout The layout
///
/// \param indexPath The index path for the item
///
///
/// returns:
/// The desired width of the item at indexPath
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout widthForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
@end


/// A vertical list based layout similiar to a native table view
SWIFT_PROTOCOL("_TtP14CollectionView32CollectionViewDelegateListLayout_")
@protocol CollectionViewDelegateListLayout <CollectionViewDelegate>
@optional
/// Asks the delegate for the height of the item at index path
/// \param collectionView The asking collection view
///
/// \param collectionViewLayout The layout
///
/// \param indexPath The index path for the item in question
///
///
/// returns:
/// The height for the item
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the height of the header in a given section
/// \param collectionView The asking collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// The desired height of section header or 0 for no header
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForHeaderInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the height of the footer in a given section.
/// \param collectionView The asking collection view
///
/// \param collectionViewLayout The layout
///
/// \param section The section of the footer in question
///
///
/// returns:
/// The desired height of the section footer or 0 for no footer
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForFooterInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for the spacing between items in a given section
/// \param collectionView The asking collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// The desired item spacing to be applied between items in the given section
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout interitemSpacingForItemsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for insets to use when laying out items in a given section
/// \param collectionView The asking collection view
///
/// \param collectionViewLayout The layout
///
/// \param section A section index
///
///
/// returns:
/// The edge insets for the section
- (NSEdgeInsets)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout insetForSectionAt:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC14CollectionView26CollectionViewDocumentView")
@interface CollectionViewDocumentView : NSView
@property (nonatomic, readonly, getter=isFlipped) BOOL flipped;
- (NSRect)adjustScroll:(NSRect)newVisible SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
@end


/// The CollectionViewDragDelegate forwards system drag functions to the delegate in the context of a Collection View.
SWIFT_PROTOCOL("_TtP14CollectionView26CollectionViewDragDelegate_")
@protocol CollectionViewDragDelegate <CollectionViewDelegate>
@optional
/// Asks the delegate if a dragging session should be started
/// \param collectionView The collection view
///
/// \param indexPath The indexpath at the location of the drag
///
/// \param event The mouse event
///
///
/// returns:
/// True if a dragging session should begin
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldBeginDraggingAt:(NSIndexPath * _Nonnull)indexPath with:(NSEvent * _Nonnull)event SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate to validate the selected items for drag.
/// This provides an opputunity to exclude some of the selected index paths from being dragged
/// \param collectionView The collection view that began the drag
///
/// \param indexPaths The selected index paths when the drag began
///
///
/// returns:
/// The index paths that should be included in the drag.
- (NSArray<NSIndexPath *> * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView validateIndexPathsForDrag:(NSArray<NSIndexPath *> * _Nonnull)indexPaths SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate that a dragging session will begin
/// If collectionView(:shouldBeginDraggingAt:with) returns false this will not be called
/// \param collectionView The collection view
///
/// \param session The dragging session
///
/// \param point The location of the drag
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView draggingSession:(NSDraggingSession * _Nonnull)session willBeginAt:(NSPoint)point;
/// Notifies the delegate that a dragging session ended
/// \param collectionView The collection view
///
/// \param session The drag session
///
/// \param screenPoint The screen point at which the drag ended
///
/// \param operation The dragging operation at the time the drag ended
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView draggingSession:(NSDraggingSession * _Nonnull)session didEndAt:(NSPoint)screenPoint with:(NSDragOperation)operation draggedIndexPaths:(NSArray<NSIndexPath *> * _Nonnull)draggedIndexPaths;
/// Notifies the delegate that a dragging session moved
/// \param collectionView The collection view
///
/// \param session The drag session
///
/// \param point The location of the drag
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView draggingSession:(NSDraggingSession * _Nonnull)session didMoveTo:(NSPoint)point;
/// Asks the delegate for an operation for the drag at its current state when it enters the collection view
/// \param collectionView The collection view
///
/// \param dragInfo The drag info
///
///
/// returns:
/// A drag operation indicating how the drag should be handled
- (NSDragOperation)collectionView:(CollectionView * _Nonnull)collectionView dragEntered:(id <NSDraggingInfo> _Nonnull)dragInfo SWIFT_WARN_UNUSED_RESULT;
/// Asks the delegate for an operation for the drag at its current state as it updates
/// \param collectionView The collection view
///
/// \param dragInfo The drag info
///
///
/// returns:
/// A drag operation indicating how the drag should be handled
- (NSDragOperation)collectionView:(CollectionView * _Nonnull)collectionView dragUpdated:(id <NSDraggingInfo> _Nonnull)dragInfo SWIFT_WARN_UNUSED_RESULT;
/// Notifies the delegate that a drag exited the collection view as a dragging destination
/// \param collectionView The collection view
///
/// \param dragInfo The drag info
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView dragExited:(id <NSDraggingInfo> _Nullable)dragInfo;
/// Notifies the delegate that a drag ended in the collection view as a dragging destination
/// \param collectionView The collection view
///
/// \param dragInfo The drag info
///
- (void)collectionView:(CollectionView * _Nonnull)collectionView dragEnded:(id <NSDraggingInfo> _Nullable)dragInfo;
/// Asks the delegate to handle the drop in the collection view
/// \param collectionView The collection view (dragging destination) the drag ended in
///
/// \param dragInfo The drag info
///
///
/// returns:
/// True if the drag is completed. False to cancel the drag
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView performDragOperation:(id <NSDraggingInfo> _Nonnull)dragInfo SWIFT_WARN_UNUSED_RESULT;
@end


/// A variation of UICollectionViewFlowLayout
/// This layout is primarily row based, but uses ItemStyles to group similar items together.
/// The layout’s delegate, CollectionViewDelegateFlowLayout, is responsible for providing a style for each item in the collection view.
/// Flow items are grouped together, always placing as many same height items in each row as possible. If the row becomes full or an flow item of a different height is provided, the layout will just to the next row and continue.
/// Span items are always placed an their own row and fill the width of the Collection View.
/// <h3>Example</h3>
/// \code
/// +---------------------------------+
/// |   +-----+ +------------+ +--+   |
/// |   |  1  | |     2      | | 3|   |
/// |   |     | |            | |  |   |
/// |   +-----+ +------------+ +--+   |
/// |   +--------+ +---------+        |
/// |   |   4    | |   5     |        |
/// |   |        | |         |        |
/// |   |        | |         |        |
/// |   |        | |         |        |
/// |   +--------+ +---------+        |
/// |   +-------------------------+   |
/// |   |         6. Span         |   |
/// |   +-------------------------+   |
/// +---------------------------------+
///
/// \endcode<h3>Transformations</h3>
/// Transformations allow you to adjust the content of each row before moving on to the next row.
/// The “center” transformation will shift the of the row to be center aligned rather than left aligned.
/// The fill tranformation will enlarge the items in a row proportionally to fill the row if their is empty space on the right. Note that this will affect the height of the entire row.
/// <h3>Spacing</h3>
/// Spacing options such as interspanSpacing and spanGroupSpacingBefore allow you to customize the space around different types of style groups.
/// The spanGroupSpacingBefore/After options will apply a set amount of space before or after a group of span items (one or more spans).
SWIFT_CLASS("_TtC14CollectionView24CollectionViewFlowLayout")
@interface CollectionViewFlowLayout : CollectionViewLayout
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A full height horizontal scrolling layout
SWIFT_CLASS("_TtC14CollectionView34CollectionViewHorizontalListLayout")
@interface CollectionViewHorizontalListLayout : CollectionViewLayout
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// A list layout that makes CollectionView a perfect alternative to NSTableView
SWIFT_CLASS("_TtC14CollectionView24CollectionViewListLayout")
@interface CollectionViewListLayout : CollectionViewLayout
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A default implementation of CollectionViewPreviewTransitionCell
SWIFT_CLASS("_TtC14CollectionView25CollectionViewPreviewCell")
@interface CollectionViewPreviewCell : CollectionViewCell
- (void)prepareForReuse;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


/// An easy to use CollectionViewController that transitions from a source collection view.
/// <h3>Presentation & Data</h3>
/// The controller is presented from a source collection view. The data source of the source collection view is used to load data for the preview collection view. The preview controller will act as a proxy between the preview collection view and your source colleciton views data source.
/// important:
/// The data source for the collection view you pass to present(in:) must conform to CollectionViewPreviewControllerDelegate
/// <h3>Transitions</h3>
/// The preview controller manages the transitions to and from the source and allows the preview cell to customize the transition.
/// Although the The preview controller will accept any cell class, supporting transitions requires a small amount of additional setup.
/// The simplest way to support transitions is to create your subclass from CollectionViewPreviewCell. CollectionViewPreviewCell will animate the frame of the cell from the source and back.
/// For custom transitions, if you subclass CollectionViewPreviewCell you can simply override the the transition methods, otherwise conform your CollectionViewCell subclass and implement the methods yourself. See CollectionViewPreviewTransitionCell for more about how to implement custom transitions
SWIFT_CLASS("_TtC14CollectionView31CollectionViewPreviewController")
@interface CollectionViewPreviewController : CollectionViewController
- (void)loadView;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
/// CollectionViewDelegatePreviewLayout
- (void)viewDidLoad;
- (void)keyUp:(NSEvent * _Nonnull)event;
- (void)cancelOperation:(id _Nullable)sender;
- (void)insertText:(id _Nonnull)insertString;
- (void)doCommandBySelector:(SEL _Nonnull)selector;
- (NSInteger)numberOfSectionsIn:(CollectionView * _Nonnull)collectionView SWIFT_WARN_UNUSED_RESULT;
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
- (CollectionViewCell * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView cellForItemAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
- (void)collectionView:(CollectionView * _Nonnull)collectionView didSelectItemsAt:(NSSet<NSIndexPath *> * _Nonnull)indexPaths;
- (BOOL)wantsScrollEventsForSwipeTrackingOnAxis:(NSEventGestureAxis)axis SWIFT_WARN_UNUSED_RESULT;
- (BOOL)wantsForwardedScrollEventsForAxis:(NSEventGestureAxis)axis SWIFT_WARN_UNUSED_RESULT;
- (void)scrollWheel:(NSEvent * _Nonnull)event;
- (nonnull instancetype)initWithNibName:(NSNibName _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC14CollectionView27CollectionViewPreviewLayout")
@interface CollectionViewPreviewLayout : CollectionViewLayout
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A results controller that does not concern itself with the order of objects, but only their membership to the supplied fetch request.
SWIFT_CLASS("_TtC14CollectionView20FetchedSetController")
@interface FetchedSetController : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC14CollectionView24HorizontalCollectionView")
@interface HorizontalCollectionView : CollectionView
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end














SWIFT_MODULE_NAMESPACE_POP
#pragma clang diagnostic pop
