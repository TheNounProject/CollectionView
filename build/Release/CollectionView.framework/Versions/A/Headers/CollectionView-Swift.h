// Generated by Apple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import AppKit;
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import CoreData;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSCoder;
@class NSWindow;

SWIFT_CLASS("_TtC14CollectionView8ClipView")
@interface ClipView : NSClipView
@property (nonatomic) CGFloat decelerationRate;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)viewWillMoveToWindow:(NSWindow * _Nullable)newWindow;
- (BOOL)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (id _Nullable)animationForKey:(NSString * _Nonnull)key;
- (void)scrollToPoint:(NSPoint)newOrigin;
@end

@class NSColor;
@class CollectionView;

/**
  The CollectionReusableView class defines the behavior for all cells and supplementary views presented by a collection view. Reusable views are so named because the collection view places them on a reuse queue rather than deleting them when they are scrolled out of the visible bounds. Such a view can then be retrieved and repurposed for a different set of content.
*/
SWIFT_CLASS("_TtC14CollectionView22CollectionReusableView")
@interface CollectionReusableView : NSView
/**
  A string that identifies the purpose of the view.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable reuseIdentifier;
/**
  The collection view the view was dequed in
*/
@property (nonatomic, readonly, weak) CollectionView * _Nullable collectionView;
/**
  True if the view has been dequed from the reuse pool
*/
@property (nonatomic, readonly) BOOL reused;
/**
  The background color of the cell
*/
@property (nonatomic, strong) NSColor * _Nullable backgroundColor;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
/**
  Performs any clean up necessary to prepare the view for use again.
*/
- (void)prepareForReuse;
/**
  Called just before the view is added to the collection view
*/
- (void)viewWillDisplay;
/**
  Called just after the view was added to the collection view
*/
- (void)viewDidDisplay;
- (void)updateLayer;
- (void)drawRect:(NSRect)dirtyRect;
@property (nonatomic) BOOL trackMouseMoved;
/**
  Disable tracking (used for highlighting in cells) for this view
*/
- (void)disableTracking;
/**
  Enable tracking for this view (called by default for cells)
*/
- (void)enableTracking;
- (void)updateTrackingAreas;
@end


SWIFT_CLASS("_TtC14CollectionView10ScrollView")
@interface ScrollView : NSScrollView
- (nonnull instancetype)initWithFrame:(NSRect)frameRect SWIFT_UNAVAILABLE;
@property (nonatomic, readonly) BOOL isFlipped;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, strong) ClipView * _Nullable clipView;
@end

@class CollectionViewDocumentView;
@class CollectionViewCell;
@class NSNib;
@class CollectionViewLayout;
@class NSEvent;
@class NSDraggingSession;
@protocol NSDraggingInfo;
@protocol CollectionViewDelegate;
@protocol CollectionViewDataSource;

/**
  A highliy customizable collection view with cell reuse, animated updates, and custom layouts
  The content of the collection view is determined by itâ€™s CollectionViewLayout. Inlcuded layouts:
  <ul>
    <li>
      CollectionViewColumnLayout
    </li>
    <li>
      CollectionViewListLayout
    </li>
    <li>
      CollectionViewFlowLayout
    </li>
  </ul>
*/
SWIFT_CLASS("_TtC14CollectionView14CollectionView")
@interface CollectionView : ScrollView <NSDraggingSource>
@property (nonatomic, readonly) BOOL mouseDownCanMoveWindow;
/**
  The object that acts as the delegate to the collection view
*/
@property (nonatomic, weak) id <CollectionViewDelegate> _Nullable delegate;
/**
  The object that provides data for the collection view
*/
@property (nonatomic, weak) id <CollectionViewDataSource> _Nullable dataSource;
/**
  The content view in which all cells and views are displayed
*/
@property (nonatomic, readonly, strong) CollectionViewDocumentView * _Nonnull contentDocumentView;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) NSScrollerStyle scrollerStyle;
@property (nonatomic, readonly) BOOL wantsUpdateLayer;
- (void)updateLayer;
/**
  Register a class to be initialized when loading reusable cells
  \param cellClass A CollectionViewCell subclass

  \param identifier A reuse identifier to deque cells of this class

*/
- (void)registerWithClass:(SWIFT_METATYPE(CollectionViewCell) _Nonnull)cellClass forCellWithReuseIdentifier:(NSString * _Nonnull)identifier;
/**
  Register a nib to be loaded as reusable cells
  \param nib The nib for the cell

  \param identifier A reuse identifier to deque cells from this nib

*/
- (void)registerWithNib:(NSNib * _Nonnull)nib forCellWithReuseIdentifier:(NSString * _Nonnull)identifier;
/**
  Register a class to be initialized when loading reusable supplementary views
  \param viewClass A CollectionReusableview subclass

  \param elementKind The kind of element the class represents

  \param identifier A reuse identifier to deque views of this class

*/
- (void)registerWithClass:(SWIFT_METATYPE(CollectionReusableView) _Nonnull)viewClass forSupplementaryViewOfKind:(NSString * _Nonnull)kind withReuseIdentifier:(NSString * _Nonnull)identifier;
/**
  Register a nib to be loaded as a supplementary view
  note:
  The nib must contain a single view whose class is set to CollectionReusableview.
  \param nib The nib for the view

  \param elementKind The kind of element this nib represents

  \param identifier A reuse identifier to deque views from this nib

*/
- (void)registerWithNib:(NSNib * _Nonnull)nib forSupplementaryViewOfKind:(NSString * _Nonnull)elementKind withReuseIdentifier:(NSString * _Nonnull)identifier;
/**
  Retrieve a cell for a given reuse identifier and index path.
  If no reusable cell is available, one is created from the registered class/nib.
  \param identifier The reuse identifier

  \param indexPath The index path specifying the location of the supplementary view to load.


  returns:
  A valid CollectionReusableView
*/
- (CollectionViewCell * _Nonnull)dequeueReusableCellWithReuseIdentifier:(NSString * _Nonnull)identifier for:(NSIndexPath * _Nonnull)indexPath;
/**
  Returns a reusable supplementary view located by its identifier and kind.
  \param elementKind The kind of supplementary view to retrieve. This value is defined by the layout object. This parameter must not be nil.

  \param identifier The reuse identifier for the specified view.

  \param indexPath The index path specifying the location of the cell to load


  returns:
  A valid CollectionViewCell
*/
- (CollectionReusableView * _Nonnull)dequeueReusableSupplementaryViewOfKind:(NSString * _Nonnull)elementKind withReuseIdentifier:(NSString * _Nonnull)identifier for:(NSIndexPath * _Nonnull)indexPath;
/**
  A view atop the collection view used to display non-scrolling accessory views
*/
@property (nonatomic, readonly, strong) NSView * _Nonnull floatingContentView;
/**
  Adds the given view to the floating content view
  \param view The view to add

*/
- (void)addAccessoryView:(NSView * _Nonnull)view;
/**
  Returns the number of sections displayed by the collection view.

  returns:
  The number of sections
*/
@property (nonatomic, readonly) NSInteger numberOfSections;
/**
  Returns the number of items in the specified section.
  \param section The index of the section for which you want a count of the items.


  returns:
  The number of items in the specified section
*/
- (NSInteger)numberOfItemsIn:(NSInteger)section;
/**
  Reloads all the data and views in the collection view
*/
- (void)reloadData;
/**
  The layout used to organize the collected viewâ€™s items.
  note:
  Assigning a new layout object to this property does <em>NOT</em> apply the layout to the collection view. Call \code
  reloadData()
  \endcode or \code
  reloadLayout(_:)
  \endcode to do so.
*/
@property (nonatomic, strong) CollectionViewLayout * _Nonnull collectionViewLayout;
/**
  The visible rect of the document view that is visible
*/
@property (nonatomic, readonly) CGRect contentVisibleRect;
/**
  The total size of all items/views
*/
@property (nonatomic, readonly) NSSize contentSize;
/**
  The offset of the content view
*/
@property (nonatomic) CGPoint contentOffset;
/**
  Force layout of all items, not just those in the visible content area
  note:
  This is not recommended for large data sets. It can be useful for smaller collection views to better manage transitions/animations.
*/
@property (nonatomic) BOOL prepareAll;
/**
  Reload the data (section & item counts) when the collectionView bounds change. Defaults to false.
  Set to \code
  true
  \endcode if the number of sections or items per section can change depending on the collection viewâ€™s size
  note:

  This will only be applied if the layout is also invalidated via \code
  shouldInvalidateLayout(forBoundsChange:)
  \endcode
*/
@property (nonatomic) BOOL reloadDataOnBoundsChange;
- (void)layout;
- (void)viewWillStartLiveResize;
- (void)viewDidEndLiveResize;
+ (BOOL)isCompatibleWithResponsiveScrolling;
@property (nonatomic) BOOL isScrollEnabled;
/**
  Returns true if the collection view is currently scrolling
*/
@property (nonatomic, readonly) BOOL isScrolling;
/**
  Returns the current velocity of a scroll in points/second
*/
@property (nonatomic, readonly) CGPoint scrollVelocity;
/**
  Returns the peak valocity of a scroll during the last scrolling session
  <h2>Example Usage</h2>
  If your cells require complex loading that may slow scrolling performance, \code
  peakScrollVelocity
  \endcode can be used to determine if the cell content should be reduced or delayed until after the scrolling ends.
  For example in CollectionViewCell
  \code
  override func viewDidDisplay() {
     if self.collectionView?.isScrolling != true ||  (self.collectionView?.peakScrollVelocity.maxAbsVelocity ?? 0) < 200 {
         // load complex content
     }
     else {
         // Wait until we are done scrolling
     }
  }

  func loadContent() { Do complex loading }

  \endcodeThen, in your collection viewâ€™s delegate
  \code
  func collectionViewDidEndScrolling(_ collectionView: CollectionView, animated: Bool) {
     guard collectionView.peakScrollVelocity.maxAbsVelocity > 200 else { return }
     for ip in collectionView.indexPathsForVisibleItems {
         if let c = collectionView.cellForItem(at:ip) as? MyCellClass {
             c.loadContent
         }
     }
  }

  \endcode*/
@property (nonatomic, readonly) CGPoint peakScrollVelocity;
/**
  Returns the lowest index path of all visible items
*/
@property (nonatomic, readonly, copy) NSIndexPath * _Nullable indexPathForFirstVisibleItem;
/**
  The duration of animations when performing animated layout changes
*/
@property (nonatomic) NSTimeInterval animationDuration;
/**
  Perform multiple updates to be applied together
  \param updates A closure in which to apply the desired changes

  \param completion A closure to call when the animation finished

*/
- (void)performBatchUpdates:(SWIFT_NOESCAPE void (^ _Nonnull)(void))updates completion:(void (^ _Nullable)(BOOL))completion;
- (void)reloadSupplementaryViewsIn:(NSIndexSet * _Nonnull)sections animated:(BOOL)animated;
/**
  Insert sections at the given indexes
  \param sections The sections to insert

  \param animated If the update should be animated
  <ul>
  </ul>

*/
- (void)insertSections:(NSIndexSet * _Nonnull)sections animated:(BOOL)animated;
/**
  Remove sections and their items
  \param sections The sections to delete

  \param animated If the update should be animated
  <ul>
  </ul>

*/
- (void)deleteSections:(NSIndexSet * _Nonnull)sections animated:(BOOL)animated;
/**
  Move a section and its items
  note:
  If called within performBatchUpdate(_:completion:):
  <ul>
    <li>
      Source should be the index prior to any other updates
    </li>
    <li>
      Destination should be the final index after all other updates
    </li>
  </ul>
  \param section The source index of the section to move

  \param newSection The destination index to move the section to

  \param animated If the move should be animated

*/
- (void)moveSection:(NSInteger)section to:(NSInteger)newSection animated:(BOOL)animated;
/**
  Insert items at specific index paths
  \param indexPaths The index paths at which to insert items.

  \param animated If the insertion should be animated

*/
- (void)insertItemsAt:(NSArray<NSIndexPath *> * _Nonnull)indexPaths animated:(BOOL)animated;
/**
  Deletes the items at the specified index paths.
  \param indexPaths The index paths for the items you want to delete

  \param animated If the updates should be animated

*/
- (void)deleteItemsAt:(NSArray<NSIndexPath *> * _Nonnull)indexPaths animated:(BOOL)animated;
/**
  Reload the items and the given index paths.
  The cells will be reloaded, asking the data source for the cell to replace with.
  \param indexPaths The index paths for the items you want to reoad

  \param animated If the updates should be animated

*/
- (void)reloadItemsAt:(NSArray<NSIndexPath *> * _Nonnull)indexPaths animated:(BOOL)animated;
/**
  Moves the item from itâ€™s current index path to another
  \param indexPath The index path for the item to move

  \param destinationIndexPath The index path to move the item to

  \param animated If the update should be animated

*/
- (void)moveItemAt:(NSIndexPath * _Nonnull)indexPath to:(NSIndexPath * _Nonnull)destinationIndexPath animated:(BOOL)animated;
/**
  If true, the delegateâ€™s \code
  collectionView(_:,mouseMovedToSection:)
  \endcode will be notified when the cursor is within a section frame
*/
@property (nonatomic) BOOL trackSectionHover;
- (void)updateTrackingAreas;
- (void)mouseExited:(NSEvent * _Nonnull)theEvent;
- (void)mouseMoved:(NSEvent * _Nonnull)theEvent;
@property (nonatomic, readonly) BOOL acceptsFirstResponder;
- (BOOL)acceptsFirstMouse:(NSEvent * _Nullable)theEvent;
- (BOOL)becomeFirstResponder;
- (BOOL)resignFirstResponder;
- (void)mouseDown:(NSEvent * _Nonnull)theEvent;
- (void)mouseUp:(NSEvent * _Nonnull)theEvent;
- (void)rightMouseDown:(NSEvent * _Nonnull)theEvent;
@property (nonatomic) NSTimeInterval keySelectInterval;
@property (nonatomic, readonly) BOOL repeatKey;
- (void)keyDown:(NSEvent * _Nonnull)theEvent;
- (void)keyUp:(NSEvent * _Nonnull)theEvent;
- (void)moveSelectionLeft:(BOOL)extendSelection;
- (void)moveSelectionRight:(BOOL)extendSelection;
- (void)moveSelectionUp:(BOOL)extendSelection;
- (void)moveSelectionDown:(BOOL)extendSelection;
/**
  If the collection view should allow selection of its items
*/
@property (nonatomic) BOOL allowsSelection;
/**
  allows the selection of multiple items via modifier keys (command & shift)
*/
@property (nonatomic) BOOL allowsMultipleSelection;
/**
  If true, clicking empty space will deselect all items
*/
@property (nonatomic) BOOL allowsEmptySelection;
/**
  The index path of the highlighted item, if any
*/
@property (nonatomic, readonly, copy) NSIndexPath * _Nullable indexPathForHighlightedItem;
/**
  Manually set the highlighted item reguardless of the cursor location
  This can be use to adust the highlighted item in response to key events
  \param indexPath The index path of the item to highlight

  \param animated If the change should be animated

*/
- (void)highlightItemAt:(NSIndexPath * _Nullable)indexPath animated:(BOOL)animated;
/**
  Returns the index paths for all selected items
*/
@property (nonatomic, readonly, copy) NSSet<NSIndexPath *> * _Nonnull indexPathsForSelectedItems;
/**
  Returns the index paths for all selected items ordered from first to last
*/
@property (nonatomic, readonly, copy) NSArray<NSIndexPath *> * _Nonnull sortedIndexPathsForSelectedItems;
/**
  Returns if the item at a given index path is selected
  \param indexPath The index path of the item to check


  returns:
  True if the item at indexPath is selected
*/
- (BOOL)itemAtIndexPathIsSelected:(NSIndexPath * _Nonnull)indexPath;
/**
  Selects all items in the collection view
  note:
  The delegate is not notified of any selections
  \param animated If the selections should be animated

*/
- (void)selectAllItems:(BOOL)animated;
/**
  Select the items at the given index paths
  note:
  The delegate is not notified of the selections
  \param indexPaths The index paths of the items you want to select

  \param animated If the selections should be animated

*/
- (void)selectItemsAt:(NSArray<NSIndexPath *> * _Nonnull)indexPaths animated:(BOOL)animated;
/**
  Deselect cells at given index paths
  note:
  The delegate will not notified of the selections
  \param indexPaths The index paths to deselect

  \param animated If the deselections should be animated

*/
- (void)deselectItemsAt:(NSArray<NSIndexPath *> * _Nonnull)indexPaths animated:(BOOL)animated;
/**
  Deselect all items in the collection view
  note:
  The delegate will not notified of the selections
  \param animated If the delselections should be animated

*/
- (void)deselectAllItems:(BOOL)animated;
/**
  Deselect the item at a given index path
  note:
  The delegate will not notified of the selections
  \param indexPath The index path for the item to deselect

  \param animated If the deselection should be animated

*/
- (void)deselectItemAt:(NSIndexPath * _Nonnull)indexPath animated:(BOOL)animated;
/**
  Returns all visible cells in the collection view
*/
@property (nonatomic, readonly, copy) NSArray<CollectionViewCell *> * _Nonnull visibleCells;
/**
  Returns the index paths for all visible cells in the collection view
*/
@property (nonatomic, readonly, copy) NSArray<NSIndexPath *> * _Nonnull indexPathsForVisibleItems;
/**
  Returns true if the item at the index path is visible
  \param indexPath The index path of an item in the collection view


  returns:
  True if the item is visible
*/
- (BOOL)itemAtIndexPathIsVisible:(NSIndexPath * _Nonnull)indexPath;
/**
  Returns the cell at a given index path if it is visible
  \param indexPath An index path of an item in the collection view


  returns:
  The cell at the indexpath, or nil if it is not visible
*/
- (CollectionViewCell * _Nullable)cellForItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  Returns the index path for a cell in the collection view
  \param cell A cell in the collection view


  returns:
  The index path of the cell, or nill if it is not visible in the collection view
*/
- (NSIndexPath * _Nullable)indexPathFor:(CollectionViewCell * _Nonnull)cell;
/**
  Returns a index path for the item at a given point
  \param point A point within the collection views contentVisibleRect


  returns:
  The index path of the item at point, if any
*/
- (NSIndexPath * _Nullable)indexPathForItemAt:(CGPoint)point;
/**
  Returns the first index path within a given distance of a point
  \param point A point within the contentDocumentViewâ€™s frame

  \param radius The distance around the point to check


  returns:
  The index path for a matching item or nil if no items were found
*/
- (NSIndexPath * _Nullable)firstIndexPathForItemWithNear:(CGPoint)point radius:(CGFloat)radius;
/**
  Returns the first index path found intersecting a given rect
  \param rect A rect within the contentDocumentViewâ€™s frame


  returns:
  The index path for the matching item or nil if no items were found
*/
- (NSIndexPath * _Nullable)firstIndexPathForItemIn:(CGRect)rect;
/**
  Returns all items intersecting a given rect
  \param rect A rect within the contentDocumentViewâ€™s frame


  returns:
  The index paths for all items in the rect. Will be empty if no items were found
*/
- (NSArray<NSIndexPath *> * _Nonnull)indexPathsForItemsIn:(CGRect)rect;
/**
  Returns the indexPath for the section that contains the given point
  \param point The point the section must contain


  returns:
  The index path for the section contianing the point
*/
- (NSIndexPath * _Nullable)indexPathForSectionAt:(CGPoint)point;
/**
  Returns the index path for a supplementary view
  \param view The supplementary view for which you want the index path


  returns:
  The index path for the view
*/
- (NSIndexPath * _Nullable)indexPathForSupplementaryView:(CollectionReusableView * _Nonnull)view;
/**
  Returns the visible supplementary view of the given kind at indexPath
  \param kind The kind of the supplementary view

  \param indexPath The index path of the supplementary view


  returns:
  The view of kind at the given index path
*/
- (CollectionReusableView * _Nullable)supplementaryViewForElementKind:(NSString * _Nonnull)kind at:(NSIndexPath * _Nonnull)indexPath;
/**
  The index paths for items included in the currect dragging session
*/
@property (nonatomic, readonly, copy) NSArray<NSIndexPath *> * _Nonnull indexPathsForDraggingItems;
- (void)mouseDragged:(NSEvent * _Nonnull)theEvent;
- (NSDragOperation)draggingSession:(NSDraggingSession * _Nonnull)session sourceOperationMaskForDraggingContext:(NSDraggingContext)context;
- (void)draggingSession:(NSDraggingSession * _Nonnull)session willBeginAtPoint:(NSPoint)screenPoint;
- (void)draggingSession:(NSDraggingSession * _Nonnull)session movedToPoint:(NSPoint)screenPoint;
- (void)draggingSession:(NSDraggingSession * _Nonnull)session endedAtPoint:(NSPoint)screenPoint operation:(NSDragOperation)operation;
- (NSDragOperation)draggingEntered:(id <NSDraggingInfo> _Nonnull)sender;
- (void)draggingExited:(id <NSDraggingInfo> _Nullable)sender;
- (void)draggingEnded:(id <NSDraggingInfo> _Nullable)sender;
- (NSDragOperation)draggingUpdated:(id <NSDraggingInfo> _Nonnull)sender;
- (BOOL)performDragOperation:(id <NSDraggingInfo> _Nonnull)sender;
@end


@interface CollectionView (SWIFT_EXTENSION(CollectionView))
@end


/**
  A CollectionViewCell object presents the content for a single data item when that item is within the collection viewâ€™s visible bounds. You can use this class as-is or subclass it to add additional properties and methods. The layout and presentation of cells is managed by the collection view and its corresponding layout object.
*/
SWIFT_CLASS("_TtC14CollectionView18CollectionViewCell")
@interface CollectionViewCell : CollectionReusableView
- (BOOL)acceptsFirstMouse:(NSEvent * _Nullable)theEvent;
/**
  The highlight state of the cell.
*/
@property (nonatomic) BOOL highlighted;
/**
  The selection state of the cell.
*/
@property (nonatomic) BOOL selected;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
- (void)prepareForReuse;
- (void)mouseEntered:(NSEvent * _Nonnull)theEvent;
- (void)mouseExited:(NSEvent * _Nonnull)theEvent;
@end


@interface CollectionViewCell (SWIFT_EXTENSION(CollectionView))
/**
  Provide a reuse identifier for all cells of this class, defaults to the class name
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull defaultReuseIdentifier;)
+ (NSString * _Nonnull)defaultReuseIdentifier;
/**
  Register a CollectionViewCell subclass to a collection view using the classâ€™s defaultReuseIdentifier
  \param collectionView The collection view to register the class in

*/
+ (void)registerIn:(CollectionView * _Nonnull)collectionView;
/**
  Deque a cell of this class from a collection view. Uses defaultReuseIdentifier
  \param indexPath The indexPath to deque the cell for

  \param collectionView The collection view to deque the cell from


  returns:
  A valid CollectionViewCell
*/
+ (CollectionViewCell * _Nonnull)dequeFor:(NSIndexPath * _Nonnull)indexPath in:(CollectionView * _Nonnull)collectionView;
@end


/**
  The CollectionViewLayout class is an abstract base class that you subclass and use to generate layout information for a collection view. The job of a layout object is to determine the placement of cells, supplementary views inside the collection viewâ€™s bounds and to report that information to the collection view when asked. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.
*/
SWIFT_CLASS("_TtC14CollectionView20CollectionViewLayout")
@interface CollectionViewLayout : NSObject
@property (nonatomic, readonly, weak) CollectionView * _Nullable collectionView;
/**
  The size that encapsulates all views within the collection view
*/
@property (nonatomic, readonly) CGSize collectionViewContentSize;
/**
  If supporting views should be pinned to the top of the view
*/
@property (nonatomic) BOOL pinHeadersToTop;
/**
  Currently this is only called when the layout is applied to a collection view.
*/
- (void)invalidate;
/**
  Asks the layout if it should be invalidated due to a bounds change on the collection view
  \param newBounds The new bounds of the collection view


  returns:
  If the layout should be invalidated
*/
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;
- (void)prepareLayout;
/**
  Tells the layout object to update the current layout.
  <h2>Discussion</h2>
  Layout updates occur the first time the collection view presents its content and whenever the layout is invalidated explicitly or implicitly because of a change to the view. During each layout update, the collection view calls this method first to give your layout object a chance to prepare for the upcoming layout operation.
  The default implementation of this method does nothing. Subclasses can override it and use it to set up data structures or perform any initial computations needed to perform the layout later.
*/
- (void)prepare;
/**
  All the index paths to be displayed by the collection view
  Becuase the layout likely needs to process all items in the data, setting this during prepare() can cut out the overhead of the collection view having to do so itself.
*/
@property (nonatomic, copy) NSSet<NSIndexPath *> * _Nonnull allIndexPaths;
- (NSArray<NSIndexPath *> * _Nonnull)indexPathsForItemsIn:(CGRect)rect;
/**
  Returns the frame that encapsulates all the content in the section
  \param section The section to get the frame for


  returns:
  The rect containing all the views
*/
- (CGRect)rectForSection:(NSInteger)section;
/**
  Returns the rect that encapsulates just the items of a section
  \param section The section to get the content frame for


  returns:
  The rect containing all the items
*/
- (CGRect)contentRectForSection:(NSInteger)section;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/**
  A column based collection view layout with pinterest like layouts, and aspect ratio sizing.
*/
SWIFT_CLASS("_TtC14CollectionView26CollectionViewColumnLayout")
@interface CollectionViewColumnLayout : CollectionViewLayout
/**
  The default column count
*/
@property (nonatomic) NSInteger columnCount;
/**
  The spacing between each column
*/
@property (nonatomic) CGFloat columnSpacing;
/**
  The vertical spacing between items in the same column
*/
@property (nonatomic) CGFloat interitemSpacing;
/**
  The height of section header views
*/
@property (nonatomic) CGFloat headerHeight;
/**
  The height of section footer views
*/
@property (nonatomic) CGFloat footerHeight;
/**
  The default height to apply to all items
*/
@property (nonatomic) CGFloat itemHeight;
/**
  If supplementary views should respect section insets or fill the CollectionView width
*/
@property (nonatomic) BOOL insetSupplementaryViews;
/**
  Default insets for all sections
*/
@property (nonatomic) NSEdgeInsets sectionInset;
- (NSInteger)numberOfColumnsInSection:(NSInteger)section;
/**
  the calculated width of items based on the total width and number of columns (read only)
*/
@property (nonatomic, readonly) CGFloat itemWidth;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;
- (void)prepare;
@property (nonatomic, readonly) CGSize collectionViewContentSize;
- (CGRect)rectForSection:(NSInteger)section;
- (CGRect)contentRectForSection:(NSInteger)section;
- (NSArray<NSIndexPath *> * _Nonnull)indexPathsForItemsIn:(CGRect)rect;
@end


/**
  The CollectionViewDelegate protocol defines methods that allow you to manage the status, selection, highlighting, and scrolling of items in a collection view and to perform actions on those items. The methods of this protocol are all optional.
*/
SWIFT_PROTOCOL("_TtP14CollectionView22CollectionViewDelegate_")
@protocol CollectionViewDelegate
@optional
/**
  Tells the delegate that the collection view will reload itâ€™s data
  \param collectionView The collection view that will reload

*/
- (void)collectionViewWillReloadData:(CollectionView * _Nonnull)collectionView;
/**
  Tells the delegate that is completed reloading itâ€™s data
  \param collectionView The collection view that was reloaded

*/
- (void)collectionViewDidReloadData:(CollectionView * _Nonnull)collectionView;
/**
  Tells the delegate that the collection view became or resigned first responder
  \param collectionView The collection view changing status

  \param firstResponder True if the collection view is first responder

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didChangeFirstResponderStatus:(BOOL)firstResponder;
/**
  Tells the delegate that the mouse moved into a section
  note:
  trackSectionHover must be set to true on the collection view
  \param collectionView The collection view notifying you of the event

  \param indexPath the index path of the section

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView mouseMovedToSection:(NSIndexPath * _Nullable)indexPath;
/**
  Tells the delegate that the mouse was clicked down in the specified index path
  \param collectionView The collection view recieving the click

  \param indexPath The index path of the item at the click location, or nil

  \param event The click event

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView mouseDownInItemAt:(NSIndexPath * _Nullable)indexPath with:(NSEvent * _Nonnull)event;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

  \param event <#event description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView mouseUpInItemAt:(NSIndexPath * _Nullable)indexPath with:(NSEvent * _Nonnull)event;
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldHighlightItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

  \param event <#event description#>


  returns:
  <#Bool return description#>
*/
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldSelectItemAt:(NSIndexPath * _Nonnull)indexPath with:(NSEvent * _Nullable)event;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didSelectItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>


  returns:
  <#Bool return description#>
*/
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldDeselectItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didDeselectItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param pressure <#pressure description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didChangePressure:(CGFloat)pressure forItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

  \param event <#event description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didDoubleClickItemAt:(NSIndexPath * _Nonnull)indexPath with:(NSEvent * _Nonnull)event;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

  \param event <#event description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didRightClickItemAt:(NSIndexPath * _Nonnull)indexPath with:(NSEvent * _Nonnull)event;
- (void)collectionView:(CollectionView * _Nonnull)collectionView willDisplayCell:(CollectionViewCell * _Nonnull)cell forItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param elementKind <#elementKind description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView willDisplaySupplementaryView:(CollectionReusableView * _Nonnull)view ofElementKind:(NSString * _Nonnull)elementKind at:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param cell <#cell description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didEndDisplayingCell:(CollectionViewCell * _Nonnull)cell forItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param view <#view description#>

  \param elementKind <#elementKind description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didEndDisplayingSupplementaryView:(CollectionReusableView * _Nonnull)view ofElementKind:(NSString * _Nonnull)elementKind at:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>


  returns:
  <#IndexPath return description#>
*/
- (NSIndexPath * _Nullable)collectionViewLayoutAnchor:(CollectionView * _Nonnull)collectionView;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

*/
- (void)collectionViewDidEndLiveResize:(CollectionView * _Nonnull)collectionView;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>


  returns:
  <#Bool return description#>
*/
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldScrollToItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView didScrollToItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

*/
- (void)collectionViewDidScroll:(CollectionView * _Nonnull)collectionView;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

*/
- (void)collectionViewWillBeginScrolling:(CollectionView * _Nonnull)collectionView;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param animated <#animated description#>

*/
- (void)collectionViewDidEndScrolling:(CollectionView * _Nonnull)collectionView animated:(BOOL)animated;
@end

@protocol NSPasteboardWriting;
@class NSImage;

/**
  The CollectionViewDataSource is responsible for providing the data and views required by a collection view
  <h1>Overview</h1>
  At a minimum, all data source objects must implement the numberOfSections(in:), collectionView(<em>:numberOfItemsInSection:) and collectionView(</em>:cellForItemAt:) methods. These methods are responsible for returning the number of items in the collection view along with the items themselves.
*/
SWIFT_PROTOCOL("_TtP14CollectionView24CollectionViewDataSource_")
@protocol CollectionViewDataSource
/**
  Asks your data source for the number of sections in the collectin view
  \param collectionView The collection view requesting this information.


  returns:
  The number of sections in collectionView.
*/
- (NSInteger)numberOfSectionsIn:(CollectionView * _Nonnull)collectionView;
/**
  Asks your data source object for the number of items in the specified section.
  \param collectionView The collection view requesting this information.

  \param section An index number identifying a section in collectionView. This index value is 0-based.


  returns:
  The number of items in the specified section
*/
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section;
/**
  Asks your data source object for the cell that corresponds to the specified item in the collection view.
  <h1>Discussion</h1>
  Your implementation of this method is responsible for creating, configuring, and returning the appropriate cell for the given item. You do this by calling the dequeueReusableCell(withReuseIdentifier:for:) method of the collection view and passing the reuse identifier that corresponds to the cell type you want. That method always returns a valid cell object. Upon receiving the cell, you should set any properties that correspond to the data of the corresponding item, perform any additional needed configuration, and return the cell.
  You do not need to set the location of the cell inside the collection viewâ€™s bounds. The collection view sets the location of each cell automatically using the layout attributes provided by its layout object.
  \param collectionView The collection view requesting this information.

  \param indexPath The index path that specifies the location of the item.


  returns:
  A configured cell object. You must not return nil from this method.
*/
- (CollectionViewCell * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView cellForItemAt:(NSIndexPath * _Nonnull)indexPath;
@optional
/**
  Asks your data source object to provide a supplementary view to display in the collection view.
  <h1>Discussion</h1>
  Your implementation of this method is responsible for creating, configuring, and returning the appropriate supplementary view that is being requested. You do this by calling the dequeueReusableSupplementaryView(ofKind:withReuseIdentifier:for:) method of the collection view and passing the information that corresponds to the view you want. That method always returns a valid view object. Upon receiving the view, you should set any properties that correspond to the data you want to display, perform any additional needed configuration, and return the view.
  You do not need to set the location of the supplementary view inside the collection viewâ€™s bounds. The collection view sets the location of each view using the layout attributes provided by its layout object.
  \param collectionView The collection view requesting this information.

  \param kind The kind of supplementary view to provide. The value of this string is defined by the layout object that supports the supplementary view.

  \param indexPath The index path that specifies the location of the new supplementary view.


  returns:
  A configured supplementary view object. You must not return nil from this method.
*/
- (CollectionReusableView * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView viewForSupplementaryElementOfKind:(NSString * _Nonnull)kind at:(NSIndexPath * _Nonnull)indexPath;
/**
  Asks your data source for a pasteboard writing for the item at the specified index path
  \param collectionView The collection view requesting this information.

  \param indexPath The index path of the item to represent with the pasteboard writer


  returns:
  An object adoption NSPasteboardWriting to represent the item, or nil
*/
- (id <NSPasteboardWriting> _Nullable)collectionView:(CollectionView * _Nonnull)collectionView pasteboardWriterForItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  Asks the data source for the drag contents for the item at the specified index path
  note:
  If nil is returned, a snapshot of the cell will be used. To disable dragging for an item return false for shouldStartDragging or remove the index path during validation
  \param collectionView The collection view requesting this information.

  \param indexPath The index path of the item to represent


  returns:
  An NSImage to display when dragging the item
*/
- (NSImage * _Nullable)collectionView:(CollectionView * _Nonnull)collectionView dragContentsForItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  Tells the data source the current rect of the item being dragging, allowing for adjustment.
  \param collectionView The collection view requesting this information.

  \param indexPath The index path of the item being dragged

  \param rect The current rect of the item

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView dragRectForItemAt:(NSIndexPath * _Nonnull)indexPath withStartingRect:(CGRect * _Nonnull)rect;
@end

@class NSBundle;

/**
  The UICollectionViewController class represents a view controller whose content consists of a collection view.
*/
SWIFT_CLASS("_TtC14CollectionView24CollectionViewController")
@interface CollectionViewController : NSViewController <CollectionViewDataSource, CollectionViewDelegate>
@property (nonatomic, readonly, strong) CollectionView * _Nonnull collectionView;
- (void)loadView;
- (void)viewDidLoad;
/**
  Adjust the layout constraints for the collection view
  \param insets The insets to apply to the collection view

*/
- (void)adjustContentInsets:(NSEdgeInsets)insets;
- (NSInteger)numberOfSectionsIn:(CollectionView * _Nonnull)collectionView;
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section;
- (CollectionViewCell * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView cellForItemAt:(NSIndexPath * _Nonnull)indexPath;
- (nullable instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/**
  The delegate for CollectionViewLayout
*/
SWIFT_PROTOCOL("_TtP14CollectionView34CollectionViewDelegateColumnLayout_")
@protocol CollectionViewDelegateColumnLayout <CollectionViewDelegate>
@optional
/**
  The height for the item at the given indexPath (Priority 2)
  \param collectionView The collection view the item is in

  \param collectionViewLayout The CollectionViewLayout

  \param indexPath The indexPath for the item


  returns:
  The height for the item
*/
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  The aspect ration for the item at the given indexPath (Priority 1). Width and height must be greater than 0.
  \param collectionView The collection view the item is in

  \param collectionViewLayout The CollectionViewLayout

  \param indexPath The indexPath for the item


  returns:
  The aspect ration for the item
*/
- (CGSize)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout aspectRatioForItemAt:(NSIndexPath * _Nonnull)indexPath;
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForHeaderInSection:(NSInteger)section;
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForFooterInSection:(NSInteger)section;
- (NSInteger)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout numberOfColumnsInSection:(NSInteger)section;
- (NSEdgeInsets)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout insetForSectionAt:(NSInteger)section;
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout interitemSpacingForSectionAt:(NSInteger)section;
- (CGFloat)collectionview:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout columnSpacingForSectionAt:(NSInteger)section;
@end


SWIFT_PROTOCOL("_TtP14CollectionView42CollectionViewDelegateHorizontalListLayout_")
@protocol CollectionViewDelegateHorizontalListLayout <CollectionViewDelegate>
@optional
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout widthForItemAt:(NSIndexPath * _Nonnull)indexPath;
@end


/**
  CollectionViewDelegateListLayout
*/
SWIFT_PROTOCOL("_TtP14CollectionView32CollectionViewDelegateListLayout_")
@protocol CollectionViewDelegateListLayout <CollectionViewDelegate>
@optional
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param collectionViewLayout <#collectionViewLayout description#>

  \param indexPath <#indexPath description#>


  returns:
  <#CGFloat return description#>
*/
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForItemAt:(NSIndexPath * _Nonnull)indexPath;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param collectionViewLayout <#collectionViewLayout description#>

  \param section <#section description#>


  returns:
  <#CGFloat return description#>
*/
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout interitemSpacingForItemsInSection:(NSInteger)section;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param collectionViewLayout <#collectionViewLayout description#>

  \param section <#section description#>


  returns:
  <#CGFloat return description#>
*/
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForHeaderInSection:(NSInteger)section;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param collectionViewLayout <#collectionViewLayout description#>

  \param section <#section description#>


  returns:
  <#CGFloat return description#>
*/
- (CGFloat)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout heightForFooterInSection:(NSInteger)section;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param collectionViewLayout <#collectionViewLayout description#>

  \param section <#section description#>


  returns:
  <#EdgeInsets return description#>
*/
- (NSEdgeInsets)collectionView:(CollectionView * _Nonnull)collectionView layout:(CollectionViewLayout * _Nonnull)collectionViewLayout insetForSectionAt:(NSInteger)section;
@end


SWIFT_CLASS("_TtC14CollectionView26CollectionViewDocumentView")
@interface CollectionViewDocumentView : NSView
@property (nonatomic, readonly) BOOL isFlipped;
- (NSRect)adjustScroll:(NSRect)newVisible;
- (nonnull instancetype)initWithFrame:(NSRect)frameRect OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


/**
  The CollectionViewDragDelegate
*/
SWIFT_PROTOCOL("_TtP14CollectionView26CollectionViewDragDelegate_")
@protocol CollectionViewDragDelegate <CollectionViewDelegate>
@optional
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param indexPath <#indexPath description#>

  \param event <#event description#>


  returns:
  <#Bool return description#>
*/
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView shouldBeginDraggingAt:(NSIndexPath * _Nonnull)indexPath with:(NSEvent * _Nonnull)event;
/**
  <#Description#>
  \param collectionView <#collectionView description#>


  returns:
  <#IndexPath return description#>
*/
- (NSArray<NSIndexPath *> * _Nonnull)collectionView:(CollectionView * _Nonnull)collectionView validateIndexPathsForDrag:(NSArray<NSIndexPath *> * _Nonnull)indexPaths;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param session <#session description#>

  \param point <#point description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView draggingSession:(NSDraggingSession * _Nonnull)session willBeginAt:(NSPoint)point;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param session <#session description#>

  \param screenPoint <#screenPoint description#>

  \param operation <#operation description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView draggingSession:(NSDraggingSession * _Nonnull)session didEndAt:(NSPoint)screenPoint with:(NSDragOperation)operation draggedIndexPaths:(NSArray<NSIndexPath *> * _Nonnull)draggedIndexPaths;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param session <#session description#>

  \param point <#point description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView draggingSession:(NSDraggingSession * _Nonnull)session didMoveTo:(NSPoint)point;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param dragInfo <#dragInfo description#>


  returns:
  <#NSDragOperation return description#>
*/
- (NSDragOperation)collectionView:(CollectionView * _Nonnull)collectionView dragEntered:(id <NSDraggingInfo> _Nonnull)dragInfo;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param dragInfo <#dragInfo description#>


  returns:
  <#NSDragOperation return description#>
*/
- (NSDragOperation)collectionView:(CollectionView * _Nonnull)collectionView dragUpdated:(id <NSDraggingInfo> _Nonnull)dragInfo;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param dragInfo <#dragInfo description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView dragExited:(id <NSDraggingInfo> _Nullable)dragInfo;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param dragInfo <#dragInfo description#>

*/
- (void)collectionView:(CollectionView * _Nonnull)collectionView dragEnded:(id <NSDraggingInfo> _Nullable)dragInfo;
/**
  <#Description#>
  \param collectionView <#collectionView description#>

  \param dragInfo <#dragInfo description#>


  returns:
  <#Bool return description#>
*/
- (BOOL)collectionView:(CollectionView * _Nonnull)collectionView performDragOperation:(id <NSDraggingInfo> _Nonnull)dragInfo;
@end


/**
  A variation of UICollectionViewFlowLayout
*/
SWIFT_CLASS("_TtC14CollectionView24CollectionViewFlowLayout")
@interface CollectionViewFlowLayout : CollectionViewLayout
/**
  The default spacing between items in the same row and between rows
*/
@property (nonatomic) CGFloat itemSpacing;
/**
  The default insets for all sections
*/
@property (nonatomic) NSEdgeInsets sectionInsets;
/**
  If supplementary views should be inset to section insets
*/
@property (nonatomic) BOOL insetSupplementaryViews;
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;
- (void)prepare;
- (CGRect)rectForSection:(NSInteger)section;
- (CGRect)contentRectForSection:(NSInteger)section;
- (NSArray<NSIndexPath *> * _Nonnull)indexPathsForItemsIn:(CGRect)rect;
@property (nonatomic, readonly) CGSize collectionViewContentSize;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC14CollectionView34CollectionViewHorizontalListLayout")
@interface CollectionViewHorizontalListLayout : CollectionViewLayout
@property (nonatomic) NSEdgeInsets sectionInsets;
@property (nonatomic) CGFloat itemWidth;
@property (nonatomic) CGFloat itemSpacing;
- (void)prepare;
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;
@property (nonatomic, readonly) CGSize collectionViewContentSize;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/**
  A list collection view layout for use in TableView style scroll views
*/
SWIFT_CLASS("_TtC14CollectionView24CollectionViewListLayout")
@interface CollectionViewListLayout : CollectionViewLayout
/**
  The vertical spacing between items in the same column
*/
@property (nonatomic) CGFloat interitemSpacing;
/**
  The vertical spacing between items in the same column
*/
@property (nonatomic) CGFloat itemHeight;
/**
  The height of section header views
*/
@property (nonatomic) CGFloat headerHeight;
/**
  The height of section footer views
*/
@property (nonatomic) CGFloat footerHeight;
/**
  If supplementary views should respect section insets or fill the CollectionView width
*/
@property (nonatomic) BOOL insetSupplementaryViews;
/**
  Default insets for all sections
*/
@property (nonatomic) NSEdgeInsets sectionInsets;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;
- (void)prepare;
@property (nonatomic, readonly) CGSize collectionViewContentSize;
- (CGRect)rectForSection:(NSInteger)section;
- (CGRect)contentRectForSection:(NSInteger)section;
- (NSArray<NSIndexPath *> * _Nonnull)indexPathsForItemsIn:(CGRect)rect;
@end


SWIFT_CLASS("_TtC14CollectionView24HorizontalCollectionView")
@interface HorizontalCollectionView : CollectionView
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


@interface NSManagedObject (SWIFT_EXTENSION(CollectionView))
@end


@interface NSNumber (SWIFT_EXTENSION(CollectionView))
@end


@interface NSNumber (SWIFT_EXTENSION(CollectionView))
@property (nonatomic, readonly, copy) NSString * _Nonnull displayDescription;
@end


@interface NSView (SWIFT_EXTENSION(CollectionView))
@end


#pragma clang diagnostic pop
